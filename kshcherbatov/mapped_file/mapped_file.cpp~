//
// Created by kir on 29.04.16.
//

#include "mapped_file.h"
#include "logger.h"
#include "hash_table.h"
#include "errno.h"
#include <unistd.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/sysinfo.h>

const size_t Page_size = (size_t)sysconf(_SC_PAGE_SIZE);
const size_t Chunk_size = Page_size*1024;

struct chunk_t {
    void *mapped_area;
    ssize_t mapped_area_ca_size;
    off_t ca_offset;
    ssize_t reference_counter;
};

struct mapped_file_t {
    int fd;

    ssize_t file_size;
    ssize_t chunk_size;

    struct hash_t chunk_ht;

    bool file_mapped;
    chunk_t chunk_cache;
    size_t cache_mem_av;
};

struct complex_key_t {
    size_t size;
    off_t offset;
};


#define VALID_OR_NULL(condition, msg) \
    do {if (!condition) {LOG_ERROR(msg, NULL); return NULL;}} while (0)

#define VALID_OR_NEG(condition, msg) \
    do {if (!condition) {LOG_ERROR(msg, NULL); return -1;}} while (0)

#define MAX(a, b) ((a) > (b) ? (a) : (b))

bool mapped_file_is_ok(mapped_file_t *mapped_file);
size_t hash_func(const size_t key);
bool cmp_func(const size_t key_a, const size_t key_b);
void destruct_internals_func(hash_list_t *hash_list);

mf_handle_t mf_open(const char* pathname) {
    LOG_DEBUG("Called mf_open (%s)\n", pathname);
    VALID_OR_NULL(pathname, "mf_open: Function argument pathname is a NULL pointer. Exit.\n");

    mapped_file_t *mapped_file = (mapped_file_t *)malloc(sizeof(mapped_file_t));
    VALID_OR_NULL(mapped_file, "mf_open: Failed construct memory structure. Exit.\n");

    int fd;
    if ((fd = open(pathname, O_RDWR)) < 0) {
        LOG_ERROR("mapped_file_construct: open: failed open file.\n", NULL);
        free((void *)mapped_file);
        return NULL;
    }
    mapped_file->fd = fd;

    struct stat sb;
    if (fstat(fd, &sb) == -1) {
        LOG_ERROR("mapped_file_construct: fstat: failed obtaining file info using fstat. Exit.\n", NULL);
        close(fd);
        free((void *)mapped_file);
        return NULL;
    }
    mapped_file->file_size = (size_t) sb.st_size;

    mapped_file->chunk_size = (1024*1024 / Page_size) * Page_size;

    size_t hash_table_size = 40009;
    hash_init(&mapped_file->chunk_ht, hash_table_size, hash_func, cmp_func, destruct_internals_func);

    chunk_t *chunk_cache = &mapped_file->chunk_cache;

    void *mem_ptr = mmap(NULL, (size_t)sb.st_size, PROT_WRITE, MAP_SHARED, fd, 0);
    if (mem_ptr == MAP_FAILED) {
        mapped_file->file_mapped = false;
        chunk_cache->mapped_area = NULL;
#ifndef NDEBUG
        chunk_cache->ca_offset = -1;
        chunk_cache->mapped_area_ca_size = -1;
#endif
    } else {
        mapped_file->file_mapped = true;
        chunk_cache->mapped_area = mem_ptr;
        chunk_cache->mapped_area_ca_size = (size_t)sb.st_size;
        chunk_cache->ca_offset = 0;
    }

    struct sysinfo info;
    int result = sysinfo(&info);
    assert(result == 0);

    mapped_file->cache_mem_av = 64*1024*1024;

    assert(mapped_file_is_ok(mapped_file));
    return ((mf_handle_t)mapped_file);
}

int mf_close(mf_handle_t mf) {
    LOG_DEBUG("Called mf_close ( [ %p ] )\n", mf);
    VALID_OR_NEG(mf, "mf_open: Function argument mf is a NULL pointer. Exit.\n");

    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    close(mapped_file->fd);
    hash_fini(&mapped_file->chunk_ht);

    if (mapped_file->chunk_cache.mapped_area) {
        munmap(mapped_file->chunk_cache.mapped_area, (size_t)mapped_file->chunk_cache.mapped_area_ca_size);
    }

#ifndef NDEBUG
    mapped_file->fd = -1;
    mapped_file->file_mapped = false;
    mapped_file->chunk_size = -1;
    mapped_file->file_size = -1;
    mapped_file->chunk_cache.mapped_area = NULL;
    mapped_file->chunk_cache.ca_offset = -1;
    mapped_file->chunk_cache.reference_counter = -1;
    mapped_file->chunk_cache.mapped_area_ca_size = -1;
#endif //NDEBUG

    return 0;
}

void* mf_map(mf_handle_t mf, off_t offset, size_t size, mf_mapmem_handle_t* mapmem_handle) {
    LOG_DEBUG("Called mf_map (mf = [%p], offset = %u, size = %u, mapmem_handle = [%p])\n",
              mf, offset, size, mapmem_handle);

    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    assert(mf && size >= 0 && offset >= 0 && mapmem_handle);
    VALID_OR_NULL((mf && size >= 0 && offset >= 0 && mapmem_handle),
                  "mf_map: Invalid function argument. Exit.\n");

    if (mapped_file->file_mapped) {
        *mapmem_handle = NULL;
        (void *)&(((char *)mapped_file->chunk_cache.mapped_area)[offset]);
    }

    size_t chunk_size = (size_t)mapped_file->chunk_size;

#define MAKE_CA(size) (((size) / chunk_size) * chunk_size)
    size_t chunk_ca_offset = MAKE_CA(offset);
    size_t chunk_offset_diff = offset - chunk_ca_offset;
    size += chunk_offset_diff;
    size_t chunk_ca_size = MAKE_CA(size);
    if (size % chunk_size)
        chunk_ca_size += chunk_size;
#undef MAKE_CA

    complex_key_t key;
    key.offset = chunk_ca_offset;
    key.size = chunk_ca_size;

    chunk_t *chunk = (chunk_t *)hash_find(&mapped_file->chunk_ht, (size_t)&key);
    if (chunk) {
        LOG_DEBUG("mf_map: Required chunk already exists\n", NULL);
        chunk->reference_counter++;
        *mapmem_handle = (mf_mapmem_handle_t *)chunk;
        return (void *)&(((char *)chunk->mapped_area)[chunk_offset_diff]);
    }

    LOG_DEBUG("mf_map: Constructing new chunk\n");

    void *mapped_area = mmap(NULL, chunk_ca_size, PROT_WRITE, MAP_SHARED, mapped_file->fd, chunk_ca_offset);
    if (mapped_area == MAP_FAILED) {
        LOG_ERROR("mf_map: Failed mmap area.\n", NULL);
        return NULL;
    }

    chunk = (chunk_t *)malloc(sizeof(chunk_t));
    assert(chunk);

    chunk->reference_counter = 1;
    chunk->ca_offset = chunk_ca_offset;
    chunk->mapped_area_ca_size = chunk_ca_size;
    chunk->mapped_area = mapped_area;

    complex_key_t *key2ht = (complex_key_t *)malloc(sizeof(complex_key_t));
    assert(key2ht);
    memcpy(key2ht, &key, sizeof(complex_key_t));

    hash_add_data(&mapped_file->chunk_ht, (size_t)key2ht, chunk);

    *mapmem_handle = (mf_mapmem_handle_t *)chunk;
    return (void *)&(((char *)mapped_area)[chunk_offset_diff]);
}

int mf_unmap(mf_handle_t mf, mf_mapmem_handle_t mapmem_handle) {
    LOG_DEBUG("Called mf_unmap (mf = [%p], mapmem_handle = %u)\n", mf, mapmem_handle);
    assert(mf);
    VALID_OR_NEG((mf), "mf_unmap: Invalid function argument. Exit.\n");

    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    if (mapped_file->file_mapped)
        return 0;

    chunk_t *chunk = (chunk_t *)mapmem_handle;

    if (chunk->reference_counter > 0)
        chunk->reference_counter--;

    if (chunk->reference_counter > 0)
        return 0;

    LOG_DEBUG("mf_unmap: This chunk is no more usefull. Destruct it.\n");

    complex_key_t key;
    key.offset = chunk->ca_offset;
    key.size = (size_t)chunk->mapped_area_ca_size;

    int result = hash_delete_data(&mapped_file->chunk_ht, (size_t)&key);
    // this include chunk unmapping and destructing as we inited hash with such elem destructor
    assert(result == 0);

    return 0;
}

static void *cache_mem_region(mapped_file_t *mapped_file, size_t offset, size_t size) {
    assert(mapped_file_is_ok(mapped_file));
    assert(offset + size <= mapped_file->file_size);

    chunk_t *chunk_cache = &mapped_file->chunk_cache;

    if (chunk_cache->mapped_area && chunk_cache->ca_offset <= offset
            && chunk_cache->ca_offset + chunk_cache->mapped_area_ca_size >= offset + size) {
        // cache fit
        return  (void *)&(((char *)chunk_cache->mapped_area)[offset - chunk_cache->ca_offset]);
    }

    if (chunk_cache->mapped_area) {
        munmap(chunk_cache->mapped_area, (size_t)chunk_cache->mapped_area_ca_size);
        chunk_cache->mapped_area = NULL;
    }
    
    size = MAX(size, 4*1024*1024);
    
    size_t chunk_ca_offset = (offset / Page_size) * Page_size;
    size_t chunk_offset_diff = offset - chunk_ca_offset;
    size += chunk_offset_diff;

    void *mem_ptr = mmap(NULL, size, PROT_WRITE, MAP_SHARED, mapped_file->fd, chunk_ca_offset);
    if (mem_ptr == MAP_FAILED)
        return NULL;

    chunk_cache->mapped_area = mem_ptr;
    chunk_cache->ca_offset = chunk_ca_offset;
    chunk_cache->mapped_area_ca_size = size;

    return (void *)&(((char *)mem_ptr)[chunk_offset_diff]);;
}

ssize_t mf_read(mf_handle_t mf, void* buf, size_t count, off_t offset) {
    LOG_DEBUG("Called mf_read (mf = [%p], buf = [%p], count = %u, offset = %u)\n", mf, buf, count, offset);
    
    if (count == 0)
        return 0;
    
    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    size_t file_size = (size_t)mapped_file->file_size;

    assert(mf && buf && count > 0 && offset >= 0 && offset <= file_size);
    VALID_OR_NEG((mf && buf && count > 0 && offset >= 0 && offset <= file_size),
                 "mf_unmap: Invalid function argument. Exit.\n");

    chunk_t *chunk_cache = &mapped_file->chunk_cache;

    size_t mem_size = (offset + count > file_size) ? file_size - offset : count;
    void *mem_ptr = cache_mem_region(mapped_file, offset, mem_size);

    assert(mapped_file->file_mapped || offset - chunk_cache->ca_offset == 0);

    memcpy(buf, mem_ptr, count);
    if (!mapped_file->file_mapped && mapped_file->cache_mem_av <= count) {
        munmap(chunk_cache->mapped_area, (size_t)chunk_cache->mapped_area_ca_size);
        chunk_cache->mapped_area = NULL;
    }

    return count;
}

ssize_t mf_write(mf_handle_t mf, const void* buf, size_t count, off_t offset) {
    LOG_DEBUG("Called mf_read (mf = [%p], buf = [%p], count = %u, offset = %u)\n", mf, buf, count, offset);

    if (count == 0)
        return 0;
        
    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    size_t file_size = (size_t)mapped_file->file_size;

    assert(mf && buf && count > 0 && offset >= 0 && offset <= file_size);
    VALID_OR_NEG((mf && buf && count > 0 && offset >= 0 && offset <= file_size),
                 "mf_unmap: Invalid function argument. Exit.\n");

    chunk_t *chunk_cache = &mapped_file->chunk_cache;

    size_t mem_size = (offset + count > file_size) ? file_size - offset : count;
    void *mem_ptr = cache_mem_region(mapped_file, offset, mem_size);
    
    assert(mapped_file->file_mapped || offset - chunk_cache->ca_offset == 0);

    memcpy(mem_ptr, buf, count);
    if (!mapped_file->file_mapped && mapped_file->cache_mem_av <= count) {
        munmap(chunk_cache->mapped_area, (size_t)chunk_cache->mapped_area_ca_size);
        chunk_cache->mapped_area = NULL;
    }

    return count;
}

off_t mf_file_size(mf_handle_t mf) {
    LOG_DEBUG("Called mf_file_size ( [ %p ] )\n", mf);
    assert(mf);
    VALID_OR_NEG(mf, "mf_file_size: Function argument mf is a NULL pointer. Exit.\n");

    mapped_file_t *mapped_file = (mapped_file_t *)mf;
    assert(mapped_file_is_ok(mapped_file));

    return mapped_file->file_size;
}

bool mapped_file_is_ok(mapped_file_t *mapped_file) {
    assert(mapped_file);
    return hash_is_ok(&(mapped_file->chunk_ht)) && mapped_file->chunk_size > 0
           && (mapped_file->fd >= 0) && (mapped_file->file_size >= 0)
           && ((!mapped_file->file_mapped) || (mapped_file->file_mapped && mapped_file->chunk_cache.mapped_area));
}


size_t hash_func(const size_t key) {
    complex_key_t *obj = (complex_key_t *)key;
    assert(obj);

    return obj->offset ^ obj->size;
}

bool cmp_func(const size_t key_a, const size_t key_b) {
    complex_key_t *obj_a = (complex_key_t *)key_a;
    assert(obj_a);

    complex_key_t *obj_b = (complex_key_t *)key_b;
    assert(obj_b);

    return (obj_a->offset == obj_b->offset) && (obj_a->size == obj_b->size);
}

void destruct_internals_func(hash_list_t *hash_list) {
    assert(hash_list);

    free((void *)hash_list->key); //complex_key_t

    chunk_t *chunk = (chunk_t *)hash_list->data;
    assert(chunk);
    munmap(chunk->mapped_area, (size_t)chunk->mapped_area_ca_size);
    free(hash_list->data); //chunk_t

#ifndef NDEBUG
    hash_list->data = NULL;
    hash_list->next = NULL;
#endif //NDEBUG
}
